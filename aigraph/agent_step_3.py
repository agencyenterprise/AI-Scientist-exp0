import logging

from langchain.chat_models import init_chat_model
from langgraph.graph import END, START, StateGraph
from langgraph.graph.state import CompiledStateGraph
from langgraph.runtime import Runtime
from pydantic import BaseModel

from aigraph import prompts, utils

logger = logging.getLogger(__name__)


# Pydantic schemas for structured outputs
class GeneratePlotCodeSchema(BaseModel):
    code: str
    dependencies: list[str]


class EvaluatePlotsSchema(BaseModel):
    is_complete: bool
    feedback: str


class State(BaseModel):
    # inputs
    task: utils.Task
    code: str

    # generated by `node_generate_plotting`
    plotting_code: str | None = None
    plotting_plan: str | None = None
    plotting_deps: list[str] = []

    # generated by `node_run_plotting`
    plotting_stdout: str | None = None
    plotting_stderr: str | None = None
    plotting_returncode: int | None = None
    plotting_directory: str | None = None
    plotting_filename: str | None = None


class Context(BaseModel):
    model: str = "gpt-4o-mini"
    temperature: float = 0.0


async def node_code_plotting(state: State, runtime: Runtime[Context]) -> State:
    logger.info("Starting node_code_plotting")

    class Schema(BaseModel):
        code: str
        plan: str
        dependencies: list[str]

    llm = init_chat_model(
        model=runtime.context.model, temperature=runtime.context.temperature
    )
    llms = llm.with_structured_output(Schema)

    prompt = prompts.build_prompt_generate_plotting_code(
        code=state.code,
        data="",  # TODO: add correct data paths
    )

    response: Schema = await llms.ainvoke(prompt)  # type: ignore
    state.plotting_code = response.code
    state.plotting_plan = response.plan
    state.plotting_deps = response.dependencies

    logger.info("node_code_plotting completed")
    return state


async def node_exec_plotting(state: State, runtime: Runtime[Context]) -> State:
    logger.info("Starting node_exec_plotting")

    code = state.plotting_code or ""
    dependencies = state.plotting_deps or []

    result = await utils.exec_code(code, dependencies)
    state.plotting_stdout = result.stdout
    state.plotting_stderr = result.stderr
    state.plotting_returncode = result.returncode
    state.plotting_directory = result.directory
    state.plotting_filename = result.filename

    logger.info("node_exec_plotting completed")
    return state


def build() -> CompiledStateGraph[State, Context, State, State]:
    """Build the Stage 3 plotting graph."""
    builder = StateGraph(state_schema=State, context_schema=Context)

    # Add nodes
    builder.add_node("code_plotting", node_code_plotting)
    builder.add_node("exec_plotting", node_exec_plotting)

    # Add edges (linear flow)
    builder.add_edge(START, "code_plotting")
    builder.add_edge("code_plotting", "exec_plotting")
    builder.add_edge("exec_plotting", END)

    return builder.compile()  # type: ignore
